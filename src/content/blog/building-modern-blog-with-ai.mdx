---
title: 'Building a Modern Tech Blog with AI: A Journey with Cursor and Claude'
description: 'An in-depth exploration of creating a full-featured tech blog using Astro, React, and modern DevOps practices, all with AI assistance'
pubDate: '2024-03-23'
heroImage: '/blog/modern-tech-stack.jpg'
---

import { TechStack } from '../../components/TechStack';
import { Pipeline } from '../../components/Pipeline';

In the rapidly evolving landscape of web development, creating a modern tech blog requires navigating through numerous frameworks, tools, and best practices. This journey was made significantly more manageable through AI assistance, specifically using Cursor IDE powered by Claude 3.5 Sonnet. Here's a detailed look at how we built this blog, combining DevOps expertise with modern web development practices.

## Technology Stack

The foundation of any successful web project lies in its technology choices. For this blog, we carefully selected a stack that prioritizes performance, developer experience, and maintainability. Our choices reflect modern best practices while keeping the architecture simple and efficient.

<TechStack client:load />

## Project Overview

This blog showcases modern web development practices through AI-assisted development, featuring:

**Core Features:**

- ‚ö° Static-first architecture with strategic interactivity
- üöÄ Automated CI/CD pipeline with 6-stage workflow
- üìä Real-time analytics and visit tracking
- üí¨ GitHub-powered comments system
- üåê Global edge deployment via Cloudflare

**Development Approach:**

- AI-assisted workflow using Cursor IDE and Claude 3.5 Sonnet
- Type-safe development with end-to-end TypeScript coverage
- Performance-first approach with zero JavaScript by default
- Enterprise-grade security with proper CORS and validation

**Infrastructure Highlights:**

- Cloudflare Pages for global content delivery
- Cloudflare Workers for serverless API functionality
- KV storage for persistent data (visit counts, analytics)
- GitHub Actions for comprehensive CI/CD automation
- Playwright for reliable end-to-end testing

## Architecture Overview

### Frontend: Astro at the Core

The frontend architecture centers around Astro, a modern static site generator that excels at building content-focused websites. Astro's "islands" architecture allows us to deliver zero JavaScript by default while strategically adding interactivity where needed. This approach results in blazing-fast page loads and optimal performance.

The key strengths of our frontend implementation include:

- **Zero JavaScript by Default**: Pages load instantly with minimal overhead
- **Strategic Interactivity**: React components load only when needed
- **Type-Safe Development**: Full TypeScript integration throughout
- **Modern Styling**: Component-based CSS with responsive designs

### Content Management

Content creation and management are streamlined through MDX, providing a powerful authoring experience that combines Markdown's simplicity with JSX's flexibility. This setup enables:

Rich content authoring with live components, frontmatter validation for consistent metadata, and type-safe content handling that catches errors before they reach production. The system also supports efficient asset co-location, keeping related resources organized and easily manageable.

### Backend: Cloudflare's Edge Infrastructure

Our backend leverages Cloudflare's powerful ecosystem, delivering content from the edge for optimal performance worldwide. The infrastructure is built on:

**Cloudflare Pages** provides:

- Global CDN distribution for fast access worldwide
- Zero-config HTTPS for security
- Automated deployments integrated with our CI/CD pipeline
- Edge computing capabilities for dynamic features

**Workers and KV** enable serverless functions with global edge storage:

```typescript
// Example: Visit Counter API
export const onRequest: PagesFunction<Env> = async (
  context: EventContext<Env, string, unknown>
) => {
  try {
    const { request, env } = context;
    const origin = request.headers.get('origin');

    // Verify KV namespace binding
    if (!env.VISIT_COUNTS) {
      throw new Error('VISIT_COUNTS KV namespace is not bound');
    }

    // Get the blog post path from the context params
    const path = `/blog/${context.params.path}`;

    // Get current count
    let currentCount: VisitCount = ((await env.VISIT_COUNTS.get(path, 'json')) as VisitCount) || {
      total: 0,
    };

    // Increment and update count
    const newCount = { total: currentCount.total + 1 };
    await env.VISIT_COUNTS.put(path, JSON.stringify(newCount));

    return new Response(JSON.stringify(newCount), {
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin':
          origin && ALLOWED_ORIGINS.includes(origin) ? origin : 'https://blog.radaideh.info',
      },
    });
  } catch (error) {
    console.error('Visit counter error:', error);
    return new Response(JSON.stringify({ error: 'Internal server error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    });
  }
};
```

<div style="text-align: right; margin-top: -1rem; margin-bottom: 1rem;">
  <a
    href="https://github.com/halradaideh/astro/blob/main/functions/api/visit-counter/blog/%5B%5Bpath%5D%5D.ts"
    target="_blank"
    rel="noopener noreferrer"
    style="font-size: 0.8rem; color: var(--text-muted); text-decoration: none;"
  >
    üîó Source
  </a>
</div>

## Development Workflow

Our development process is built around modern tools and practices that enhance productivity while maintaining code quality. The workflow is automated through a comprehensive 6-stage CI/CD pipeline:

<Pipeline client:load />

### Pipeline Overview

The complete CI/CD pipeline consists of 6 jobs with clear dependencies that ensure code quality, security, and reliable deployments through modern DevOps practices including semantic versioning, automated releases, and robust error handling.

### Local Development Environment

The development environment is configured for optimal productivity:

```javascript
// astro.config.mjs
import { defineConfig } from 'astro/config';
import mdx from '@astrojs/mdx';
import sitemap from '@astrojs/sitemap';
import react from '@astrojs/react';

export default defineConfig({
  site: 'https://blog.radaideh.info',
  integrations: [
    mdx(),
    sitemap(),
    react({
      include: ['**/react/*', '**/components/**/*.{jsx,tsx}'],
      experimentalReactChildren: true,
    }),
  ],
  vite: {
    define: {
      'import.meta.env.GISCUS_REPO': JSON.stringify(process.env.GISCUS_REPO),
      'import.meta.env.GISCUS_REPO_ID': JSON.stringify(process.env.GISCUS_REPO_ID),
      'import.meta.env.GISCUS_CATEGORY': JSON.stringify(process.env.GISCUS_CATEGORY || 'General'),
      'import.meta.env.GISCUS_CATEGORY_ID': JSON.stringify(process.env.GISCUS_CATEGORY_ID),
    },
  },
});
```

<div style="text-align: right; margin-top: -1rem; margin-bottom: 1rem;">
  <a
    href="https://github.com/halradaideh/astro/blob/main/astro.config.mjs"
    target="_blank"
    rel="noopener noreferrer"
    style="font-size: 0.8rem; color: var(--text-muted); text-decoration: none;"
  >
    üîó Source
  </a>
</div>

### Type Safety and Data Management

TypeScript provides end-to-end type safety, crucial for maintaining a robust codebase:

```typescript
// functions/types.ts
export interface Env {
  LIKES: KVNamespace;
  VISIT_COUNTS: KVNamespace;
}

export interface VisitCount {
  total: number;
}

export interface LikeData {
  count: number;
  users: Array<{
    login: string;
    avatar_url: string;
  }>;
}

export type Context = EventContext<Env, string, unknown>;
```

<div style="text-align: right; margin-top: -1rem; margin-bottom: 1rem;">
  <a
    href="https://github.com/halradaideh/astro/blob/main/functions/types.ts"
    target="_blank"
    rel="noopener noreferrer"
    style="font-size: 0.8rem; color: var(--text-muted); text-decoration: none;"
  >
    üîó Source
  </a>
</div>

## CI/CD Pipeline Implementation Details

Building on the pipeline overview in our Development Workflow, here are the detailed implementations of each stage:

### Workflow Configuration and Environment

The pipeline starts with extensive configuration management:

```yaml
# .github/workflows/ci.yml (configuration excerpt)
env:
  # Node and Package Management
  NODE_VERSION: 'latest'
  NPM_VERSION: 'latest'
  WRANGLER_VERSION: '3.28.2'

  # Project Configuration
  PROJECT_NAME: 'blog-radaideh-info'
  CUSTOM_DOMAIN: 'blog.radaideh.info'
  DIST_DIR: './dist'

  # Worker and KV Configuration
  WORKER_NAME: 'blog-worker'
  DEPLOYMENT_ENV: 'production'
  KV_STATS_NAME: 'BLOG_STATS'
  KV_VIEWS_NAME: 'BLOG_VIEWS'
  KV_REACTIONS_NAME: 'BLOG_REACTIONS'

# Concurrency control for efficiency
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true
```

<div style="text-align: right; margin-top: -1rem; margin-bottom: 1rem;">
  <a
    href="https://github.com/halradaideh/astro/blob/main/.github/workflows/ci.yml"
    target="_blank"
    rel="noopener noreferrer"
    style="font-size: 0.8rem; color: var(--text-muted); text-decoration: none;"
  >
    üîó Source
  </a>
</div>

### Stage 1: Quality Assurance Pipeline

The first stage focuses on code quality and standards:

```yaml
# Quality checks run in parallel with comprehensive validation
quality-checks:
  runs-on: ubuntu-latest
  steps:
    - name: Run ESLint
      run: npx eslint . --ext .js,.jsx,.ts,.tsx,.astro --no-cache
    - name: Check formatting
      run: npm run format:check
    - name: Type check
      run: npm run typecheck
```

<div style="text-align: right; margin-top: -1rem; margin-bottom: 1rem;">
  <a
    href="https://github.com/halradaideh/astro/blob/main/.github/workflows/ci.yml#L51-L75"
    target="_blank"
    rel="noopener noreferrer"
    style="font-size: 0.8rem; color: var(--text-muted); text-decoration: none;"
  >
    üîó Source
  </a>
</div>

### Stage 2: End-to-End Testing

Our testing pipeline includes comprehensive Playwright tests:

```yaml
test:
  needs: [quality-checks]
  runs-on: ubuntu-latest
  steps:
    - name: Install Playwright browsers
      run: npx playwright install --with-deps
    - name: Build site
      run: npm run build
    - name: Run Playwright tests
      run: npm run test
    - name: Upload test results
      uses: actions/upload-artifact@v4
      with:
        name: playwright-report
        path: playwright-report/
        retention-days: 7
```

<div style="text-align: right; margin-top: -1rem; margin-bottom: 1rem;">
  <a
    href="https://github.com/halradaideh/astro/blob/main/.github/workflows/ci.yml#L77-L109"
    target="_blank"
    rel="noopener noreferrer"
    style="font-size: 0.8rem; color: var(--text-muted); text-decoration: none;"
  >
    üîó Source
  </a>
</div>

### Stage 3: Build Validation

Dedicated build testing to ensure production readiness:

```yaml
test-build:
  needs: [test]
  runs-on: ubuntu-latest
  steps:
    - name: Test build
      run: |
        npm run build
        if [ $? -eq 0 ]; then
          echo "Build successful!"
        else
          echo "Build failed!"
          exit 1
        fi
```

<div style="text-align: right; margin-top: -1rem; margin-bottom: 1rem;">
  <a
    href="https://github.com/halradaideh/astro/blob/main/.github/workflows/ci.yml#L111-L135"
    target="_blank"
    rel="noopener noreferrer"
    style="font-size: 0.8rem; color: var(--text-muted); text-decoration: none;"
  >
    üîó Source
  </a>
</div>

### Stage 4: Security Scanning (Parallel)

Security scanning runs in parallel with testing for efficiency:

```yaml
security-scan:
  needs: [quality-checks]
  runs-on: ubuntu-latest
  steps:
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        format: 'sarif'
        output: 'trivy-results.sarif'
    - name: Upload to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v3
```

<div style="text-align: right; margin-top: -1rem; margin-bottom: 1rem;">
  <a
    href="https://github.com/halradaideh/astro/blob/main/.github/workflows/ci.yml#L137-L154"
    target="_blank"
    rel="noopener noreferrer"
    style="font-size: 0.8rem; color: var(--text-muted); text-decoration: none;"
  >
    üîó Source
  </a>
</div>

### Stage 5: Release Preparation

Semantic versioning and release management:

```yaml
prepare-release:
  needs: [test-build]
  steps:
    - name: Determine version bump
      uses: actions/github-script@v7
      with:
        script: |
          let bump = 'patch';
          if (context.eventName === 'pull_request') {
            const labels = context.payload.pull_request.labels.map(l => l.name);
            if (labels.includes('major')) bump = 'major';
            else if (labels.includes('minor')) bump = 'minor';
          }
          core.setOutput('bump', bump);

    - name: Create Git Tag and Release
      run: |
        git tag -a "v${{ steps.versioning.outputs.new_version }}" \
                  -m "Release v${{ steps.versioning.outputs.new_version }}"
        git push origin "v${{ steps.versioning.outputs.new_version }}"
```

<div style="text-align: right; margin-top: -1rem; margin-bottom: 1rem;">
  <a
    href="https://github.com/halradaideh/astro/blob/main/.github/workflows/ci.yml#L156-L220"
    target="_blank"
    rel="noopener noreferrer"
    style="font-size: 0.8rem; color: var(--text-muted); text-decoration: none;"
  >
    üîó Source
  </a>
</div>

### Build Artifact Management

The pipeline efficiently manages build artifacts between jobs:

```yaml
- name: Upload build artifacts
  uses: actions/upload-artifact@v4
  with:
    name: dist
    path: ${{ env.DIST_DIR }}
    retention-days: 1

# Later in deploy job
- name: Download build artifacts
  uses: actions/download-artifact@v4
  with:
    name: dist
    path: ${{ env.DIST_DIR }}
```

<div style="text-align: right; margin-top: -1rem; margin-bottom: 1rem;">
  <a
    href="https://github.com/halradaideh/astro/blob/main/.github/workflows/ci.yml#L193-L199"
    target="_blank"
    rel="noopener noreferrer"
    style="font-size: 0.8rem; color: var(--text-muted); text-decoration: none;"
  >
    üîó Source
  </a>
</div>

### Stage 6: Production Deployment

Final deployment to Cloudflare Pages with comprehensive configuration:

```yaml
# Source: https://github.com/halradaideh/astro/blob/main/.github/workflows/ci.yml#L282-L322
deploy:
  needs: [prepare-release]
  environment: production
  steps:
    - name: Deploy to Cloudflare Pages
      uses: cloudflare/pages-action@v1
      with:
        apiToken: ${{ secrets.CF_API_TOKEN }}
        accountId: ${{ secrets.CF_ACCOUNT_ID }}
        projectName: ${{ env.PROJECT_NAME }}
        directory: ${{ env.DIST_DIR }}
        environmentVariables: |
          GISCUS_REPO=${{ secrets.GISCUS_REPO }}
          GISCUS_REPO_ID=${{ secrets.GISCUS_REPO_ID }}
          GISCUS_CATEGORY=${{ secrets.GISCUS_CATEGORY }}
          GISCUS_CATEGORY_ID=${{ secrets.GISCUS_CATEGORY_ID }}
        kv: |
          VISIT_COUNTS=${{ secrets.KV_VISIT_COUNTS_ID }}
          LIKES=${{ secrets.KV_LIKES_ID }}
```

### Automated Infrastructure Management

The pipeline automatically creates and manages Cloudflare KV namespaces:

```yaml
# Source: https://github.com/halradaideh/astro/blob/main/.github/workflows/ci.yml#L324-L333
- name: Create KV Namespaces
  run: |
    for ns in VISIT_COUNTS LIKES; do
      echo "Creating KV namespace: $ns"
      npx wrangler@${{ env.WRANGLER_VERSION }} kv:namespace create $ns || true
    done
  env:
    CLOUDFLARE_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
```

### Deployment Tracking and Notifications

The pipeline includes comprehensive deployment tracking:

```yaml
# Source: https://github.com/halradaideh/astro/blob/main/.github/workflows/ci.yml#L335-L361
- name: Update Deployment Status
  uses: actions/github-script@v7
  with:
    script: |
      const deployment = await github.rest.repos.createDeployment({
        owner, repo,
        ref: context.sha,
        environment: '${{ env.DEPLOYMENT_ENV }}',
        description: '${{ env.DEPLOYMENT_ENV }} Deployment'
      });

      const status = '${{ job.status }}' === 'success' ? 'success' : 'failure';
      await github.rest.repos.createDeploymentStatus({
        owner, repo,
        deployment_id: deployment.data.id,
        state: status,
        environment_url: 'https://${{ env.CUSTOM_DOMAIN }}',
        description: status === 'success' ? 'Deployment successful' : 'Deployment failed'
      });
```

### Failure Management

Automated issue creation for deployment failures:

```yaml
# Source: https://github.com/halradaideh/astro/blob/main/.github/workflows/ci.yml#L363-L377
- name: Notify on Failure
  if: failure()
  uses: actions/github-script@v7
  with:
    script: |
      await github.rest.issues.create({
        owner, repo,
        title: 'üö® Deployment Failed',
        body: `Deployment failed in run [#${context.runNumber}](url)
        
        Commit: ${context.sha}
        Branch: ${context.ref}`,
        labels: ['deployment', 'bug']
      });
```

### GitHub Secrets Management

The pipeline relies on several GitHub secrets that need to be configured:

- `CF_API_TOKEN` - Cloudflare API token with Pages and KV permissions
- `CF_ACCOUNT_ID` - Cloudflare account identifier
- `GISCUS_REPO` - GitHub repository for Giscus comments
- `GISCUS_REPO_ID` - Giscus repository identifier
- `GISCUS_CATEGORY` - Discussion category name
- `GISCUS_CATEGORY_ID` - Discussion category identifier
- `KV_VISIT_COUNTS_ID` - KV namespace ID for visit counting
- `KV_LIKES_ID` - KV namespace ID for post likes

### Automated Testing Strategy

We implement comprehensive end-to-end testing with Playwright to ensure functionality across all critical user journeys:

```typescript
// tests/e2e/basic.spec.ts (excerpt)
import { test, expect } from '@playwright/test';

test.describe('Blog Homepage', () => {
  test('should load homepage successfully', async ({ page }) => {
    await page.goto('/');
    await expect(page).toHaveTitle(/Hamdan Radaideh/);

    // Check main navigation elements
    await expect(page.locator('nav')).toBeVisible();
    await expect(page.getByRole('link', { name: 'Blog' })).toBeVisible();
  });

  test('should display visit counter', async ({ page }) => {
    await page.goto('/blog');
    const firstPost = page.locator('article a').first();
    await firstPost.click();

    // Should have visit counter functionality
    await expect(
      page.locator('[data-testid="visit-counter"]').or(page.getByText(/views?/i))
    ).toBeVisible({ timeout: 10000 });
  });

  test('should be responsive across devices', async ({ page }) => {
    // Test mobile viewport
    await page.setViewportSize({ width: 375, height: 667 });
    await page.goto('/');
    await expect(page.locator('nav')).toBeVisible();

    // Test tablet viewport
    await page.setViewportSize({ width: 768, height: 1024 });
    await page.goto('/');
    await expect(page.locator('nav')).toBeVisible();
  });
});

test.describe('Blog Navigation and Comments', () => {
  test('should navigate to blog posts', async ({ page }) => {
    await page.goto('/blog');

    // Click on the first blog post
    const firstPost = page.locator('article a').first();
    await expect(firstPost).toBeVisible();
    await firstPost.click();

    // Should navigate to a blog post page
    await expect(page).toHaveURL(/\/blog\/.+/);
  });

  test('should load Giscus comments system', async ({ page }) => {
    await page.goto('/blog');
    const firstPost = page.locator('article a').first();
    await firstPost.click();

    // Check for Giscus comments iframe
    await expect(page.frameLocator('iframe[title="Comments"]')).toBeVisible({ timeout: 15000 });
  });
});
```

<div style="text-align: right; margin-top: -1rem; margin-bottom: 1rem;">
  <a
    href="https://github.com/halradaideh/astro/blob/main/tests/e2e/basic.spec.ts"
    target="_blank"
    rel="noopener noreferrer"
    style="font-size: 0.8rem; color: var(--text-muted); text-decoration: none;"
  >
    üîó Source
  </a>
</div>

The testing pipeline validates:

- **Homepage functionality** - Navigation, layout, and core content loading
- **Blog post rendering** - Individual post pages and metadata display
- **Visit counter integration** - API functionality and data persistence
- **Comments system** - Giscus integration and iframe loading
- **Responsive design** - Mobile, tablet, and desktop viewports
- **Performance metrics** - Page load times and lighthouse scores
- **Accessibility standards** - WCAG compliance and screen reader support

## Performance and Security

Our approach to performance and security is comprehensive and proactive. The site achieves excellent performance through several key strategies:

**Static Generation** forms the foundation of our performance strategy. Pages are pre-rendered at build time, resulting in lightning-fast initial loads. This is enhanced by zero JavaScript by default, optimized asset loading, and automatic image optimization.

**Edge Deployment** ensures content is served from locations close to users, with:

- Global CDN distribution minimizing latency
- Automatic caching at the edge
- Edge computing for dynamic features
- Optimal worldwide performance

**Progressive Enhancement** provides a robust user experience:
The core content is always accessible, even without JavaScript enabled. Enhanced features are loaded on demand, with graceful degradation ensuring functionality across all devices and connections. The responsive design adapts seamlessly to different screen sizes.

### Security Implementation

Security is implemented through multiple layers:

**Content Security** is enforced through:

- Strict TypeScript validation prevents runtime errors
- Environment variable validation ensures proper configuration
- GitHub secrets management protects sensitive data
- Regular security scanning with Trivy identifies vulnerabilities

**API Security** includes:

```typescript
// CORS configuration with restricted origins
// Source: https://github.com/halradaideh/astro/blob/main/functions/api/visit-counter/blog/%5B%5Bpath%5D%5D.ts
const ALLOWED_ORIGINS = [
  'https://blog.radaideh.info',
  'http://localhost:4321', // For development
];

function getCorsHeaders(origin: string | null): Record<string, string> {
  const allowedOrigin = origin && ALLOWED_ORIGINS.includes(origin) ? origin : ALLOWED_ORIGINS[0];

  return {
    'Access-Control-Allow-Origin': allowedOrigin,
    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type',
    'Access-Control-Max-Age': '86400',
  };
}
```

## GitHub Integration Features

The blog leverages GitHub's ecosystem for enhanced functionality:

### Giscus Comments System

- Powered by GitHub Discussions
- Seamless authentication via GitHub
- Moderation through familiar GitHub tools
- Privacy-focused commenting experience

### Automated Deployment

- GitHub Actions for CI/CD
- Automated semantic versioning
- Release management with auto-generated notes
- Environment-specific deployments

## Lessons and Future Directions

Building this blog has been an educational journey, yielding valuable insights into modern web development practices. The integration of AI assistance through Cursor and Claude has particularly transformed our development process.

**Key Learnings:**
The combination of AI assistance and modern development tools has dramatically improved our workflow. AI has enabled rapid prototyping and iteration, while suggesting best practices and catching potential issues early. The static-first approach with progressive enhancement has proven highly effective for performance and user experience.

**Looking Forward:**
We have several exciting improvements planned:

Performance enhancements will include:

- Enhanced caching strategies
- Image optimization with next-gen formats
- Service worker implementation
- Bundle size optimization

Feature additions will focus on:

- Advanced search functionality
- Comprehensive tag system
- Related posts suggestions
- Enhanced analytics with privacy focus

## Conclusion

This project demonstrates the power of combining modern web development practices with AI assistance. The resulting platform is not just a blog, but a testament to what's possible with today's tools and technologies.

For developers embarking on similar projects, we recommend:

1. Embracing AI as a development partner
2. Focusing on performance from day one
3. Implementing comprehensive testing strategies
4. Maintaining high code quality standards
5. Planning for scalability and security

The complete source code is available on [GitHub](https://github.com/halradaideh/astro), showcasing how AI can help create production-ready applications with modern best practices, comprehensive CI/CD pipelines, and robust security measures.
